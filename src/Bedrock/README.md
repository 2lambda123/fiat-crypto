# Bedrock2 backend

The code in this subdirectory translates functions in fiat-crypto's internal
language to bedrock2 code.

## Usage

Examples of generating, translating, and proving arithmetic operations can be
found in `Tests/`. Generally, you create a fiat-crypto expression with `Reify`
and `BoundsPipeline` and then you call `translate_func` on it to get a bedrock2
function. You can then prove things about it using `translate_func_correct`.

## Structure

`Translation/` : defines functions that manipulate a fiat-crypto expression and
translate it to bedrock2.

`Proofs/` : proves that the functions in `Translation/` do their jobs
correctly. Generally, each `Translation/XYZ.v` has a `Proofs/XYZ.v` that
corresponds to it.

`Tests/` : example cases of generating operations with the fiat-crypto pipeline
and then translating to bedrock2.

`Tactics.v` : useful tactics.

`Types.v` : sets up an instantiation of the variable type for fiat-crypto's
PHOAS type system to be used in the translation, and defines some operations on
expressions with that variable type. 

`Util.v` : helper proofs not specific to this development, hopefully to be
merged upstream to coqutil or bedrock2 eventually.

`format_bedrock.sh` : convenient little script that cleans some of the notation
garbage from bedrock2 printouts, making them easier to read for debugging. 

## Method

The translation process mirrors bedrock2 abstraction levels (see bedrock2's
`Syntax.v`):

1. `expr`, for expressions that don't set local variables, store anything, or
   otherwise change state
2. `cmd`, for expressions that do set local variables. In bedrock2 these are
   also allowed to store data. However, in this fiat-crypto backend the `cmd`
level is not allowed to read from or write to memory.
3. `func`, the top level, which is allowed to handle memory. The bedrock2 code
   produced by this backend always loads input arrays into local variables
immediately, and handles everything in local variables until it's ready to
store any output arrays at the end. 

The choice to not allow the `cmd` level to modify memory was a tradeoff that
makes sense for the specific domain in which fiat-crypto operates, because you
basically always need to access all the information in your input array and
gain nothing by modifying it in place. Doing the loads immediately and the
stores at the very end also greatly simplified the proofs for the `cmd` level,
which can now assume that memory doesn't change. And it allowed
`translate_func_correct` to use *two* separation-logic preconditions instead of
one (one for the input, one for the output), which means it's possible to e.g.
add two bignums and then store the result in the first operand. The
postcondition will be stated in terms of the output precondition (so if you
stored the result in one of the inputs, you will of course lose information
about that input).

## Restrictions

Input to the bedrock2 translation must:
- contain only the subset of operations found in `Translation/Expr.v`
- have only one size of integer (uses options `widen_bytes` and `widen_carries`)
- not have functions that return multiple values, as these are untranslatable to bedrock2\*
- not use types other than integers, lists of integers, and tuples, although
  tuples can be arbitrarily nested 
- not assign anything to lists

\* bedrock2 doesn't support carries or assigning to multiple values, but if it
did start supporting them in the future the translation has most of the code in
place to handle that.

## Example snippet

To make things a little more concrete, here are a couple of corresponding
snippets (from curve25519 modular multiplication on 64-bit; see
`Tests/X25519_64.v`). Some extra notations are used for readability.

fiat-crypto expression (as generated by reification/bounds pipeline):
```
Î» x0 x1 : x type_listZ,
expr_let x2 := (unit64) ((unit64) ($x0 [[4]]) * (unit64) ((unit64) ($x1 [[4]]) * ###19)) in
expr_let x3 := (unit64)
                 (#Z_mul_high @ (###18446744073709551616)%expr @ (unit64) ($x0 [[4]]) @
                  (unit64) ((unit64) ($x1 [[4]]) * ###19))%expr_pat in

...

expr_let x150 := (unit64) ((#Z_ltz)%expr @ (unit64) $x149 @ (unit64) $x147)%expr_pat in
expr_let x151 := (unit64) ((unit64) $x150 + (unit64) $x85) in
expr_let x152 := (unit64)
                   ((unit64) ((unit64) $x149 >> ###51)
                    || (unit64)
                         ((#Z_truncating_shiftl)%expr @ (###64)%expr @ (unit64) $x151 @
                          (###13)%expr)%expr_pat) in
expr_let x153 := (unit64) ((unit64)  $x149 &' ###2251799813685247) in
expr_let x154 := (unit64) ((unit64) $x152 * ###19) in
expr_let x155 := (unit64) ((unit64) $x69 + (unit64) $x154) in
expr_let x156 := (unit64) ((unit64) $x155 >> ###51) in
expr_let x157 := (unit64) ((unit64) $x155 &' ###2251799813685247) in
expr_let x158 := (unit64) ((unit64) $x156 + (unit64) $x138) in
expr_let x159 := (unit64) ((unit64) $x158 >> ###51) in
expr_let x160 := (unit64) ((unit64) $x158 &' ###2251799813685247) in
expr_let x161 := (unit64) ((unit64) $x159 + (unit64) $x143) in
[(unit64) $x157; (unit64) $x160; (unit64) $x161; (unit64) $x148; (unit64) $x153]
```

bedrock2 expression (variable names do not correspond):
```
   (bedrock_call_lhs
    : (in0, in1, out0), [] % list,
    bedrock_func_body:(
       (((x0 = (load(in0 + 0));
          x1 = (load(in0 + 8));
          x2 = (load(in0 + 16));
          x3 = (load(in0 + 24));
          x4 = (load(in0 + 32));
          /*skip*/);
         (x5 = (load(in1 + 0));
          x6 = (load(in1 + 8));
          x7 = (load(in1 + 16));
          x8 = (load(in1 + 24));
          x9 = (load(in1 + 32));
          /*skip*/);
         /*skip*/);
    x10 = (x4 * (x9 * 19));
	x11 = mulhuu x4 (x9 * 19);

	...

    x158 = (x157 < x155);
    x159 = (x158 + x93);
    x160 = (x157 >> 51 | x159 << 13);
    x161 = (x157 & 2251799813685247);
    x162 = (x160 * 19);
    x163 = (x77 + x162);
    x164 = (x163 >> 51);
    x165 = (x163 & 2251799813685247);
    x166 = (x164 + x146);
    x167 = (x166 >> 51);
    x168 = (x166 & 2251799813685247);
    x169 = (x167 + x151);
    x170 = (x165);
    x171 = (x168);
    x172 = (x169);
    x173 = (x156);
    x174 = (x161);
    /*skip*/);
    store(out0 + 0, x170);
    store(out0 + 8, x171);
    store(out0 + 16, x172);
    store(out0 + 24, x173);
    store(out0 + 32, x174);
    /*skip*/)))
    : bedrock_func
```

Some things to note:
- the translation inserts an extra argument, `out0`, for a pointer to the
  output array. This happens automatically for all `list Z`s in the return
type.
- the bedrock2 code loads all the arguments immediately.
